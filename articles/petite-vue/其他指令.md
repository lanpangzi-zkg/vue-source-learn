# 其他指令
本篇是petite-vue源码研究文章系列的第五篇，以前的文章可[点击](https://github.com/lanpangzi-zkg/vue-source-learn)查看，今天还是接着分析一下其他常用指令，例如v-model/v-bind等指令的实现，本篇完结后就不再对指令进行讲解了，后面将梳理petite-vue的流程与设计，为这个系列画上一个句号，废话不多说，就开始今天的主题吧。

# v-model
v-model指令提供了双向数据绑定的能力，在很多场景中提供了极大的便利，先回顾一下vue官网对v-model的介绍吧:
* text 和 textarea 元素使用 value property 和 input 事件；
* checkbox 和 radio 使用 checked property 和 change 事件；
* select 字段将 value 作为 prop 并将 change 作为事件。
说得很清楚，就是为不同的表单元素绑定不同的响应事件，当目标对象状态发生变化，同步更新上下文的scope对象，scope对象由于是响应式的，因此可以触发其他依赖副作用，例如`<input v-model="text" />`，其实效果就雷同下面这个代码片段：
```
<input type="text">
<script type="text/javascript">
	const input = document.querySelector('input');
	const data = {
		_text: '',
		get text() {
			return this._text;
		},
		set text(newText) {
			this._text = newText;
			input.value = (this._text).toUpperCase(); // 为了显示同步效果，转换成大写
		}
	};
	input.addEventListener('input', (e) => {
		data.text = e.target.value;
	});
</script>
```
经过小小的例子，应该对v-model有个初步的印象了，其实最重要的作用就是事件与状态的关联同步，接下来分几个部分对其进行分析。
## 1.延迟执行
在walk函数中，当解析到v-model指令时，其实是不会立刻执行这个指令的相关逻辑的，相反，推迟到目标元素的所有其他指令执行完毕才会执行，源代码有一句注释`defer v-model since it relies on :value bindings to be processed first`，这段逻辑对应的代码如下：
``` 
let deferredModel
for (const { name, value } of [...el.attributes]) {
  if (dirRE.test(name) && name !== 'v-cloak') {
    if (name === 'v-model') {
      // defer v-model since it relies on :value bindings to be processed
      // first
      deferredModel = value
    } else {
      processDirective(el, name, value, ctx)
    }
  }
}
if (deferredModel) {
  processDirective(el, 'v-model', deferredModel, ctx)
}
```
推迟v-model的原因已经很明确了，刚开始还是有点想不明白，感觉不太需要延迟吧，但是想想下面这种情况：
```
<inut v-model="text" :type="type">
```
type不一样，会导致v-model的处理逻辑是不一样的，因此必须等到type绑定完毕才能执行v-model指令，因此这样设计是合理的。
## 2.事件绑定
前面了解到，针对不同的表单元素，需要绑定不同的事件，因此首先要判断类型，因此可以在源码中发现这样的判断：
```
const type = el.type;
if (el.tageName === 'SELECT') {
	listen(el, 'change', () => {
		...
	});
	effect(() => {
		...
	});
} else if (type === 'checkbox') {
	listen(el, 'change', () => {
		...
	});
	effect(() => {
		...
	});
} else if (type === 'radio') {
	listen(el, 'change', () => {
		...
	});
	effect(() => {
		...
	});
} else { // input/textarea
	listen(el, 'compositionstart', onCompositionStart);
    listen(el, 'compositionend', onCompositionEnd);
    listen(el, modifiers?.lazy ? 'change' : 'input', () => {
    	...
    };
    effect(() => {
    	...
    });
}
```
因此除开input/textarea对合成事件的处理外，其他处理逻辑都是类似的，首先绑定change/input事件，然后注册副作用，这样当事件回调触发时，修改上下文中的状态值，副作用effect触发，保证ui的同步更新，各种情况的具体实现这里就不细说了。
## 3.compositionEvent
在官网中，还有一段这样的描述：对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组织文字过程中得到更新。如果你也想响应这些更新，请使用 input 事件监听器和 value 绑定，而不是使用 v-model，这里就是对于compositionEvent事件不支持了，因此需要自己手动实现。那么在petite-vue中是如何处理的呢，当用户在触发合成事件的过程中，其实是阻止了目标对象input/change事件回调的发生，在compositionend触发之后，再模拟触发input事件，从而保证界面的一致性；
```
listen(el, 'compositionstart', onCompositionStart);
listen(el, 'compositionend', onCompositionEnd);
listen(el, modifiers?.lazy ? 'change' : 'input', () => {
  if (el.composing) { // 如果是合成事件，直接return，因此发生compositionEvent，都不会执行update
	  return;
  }
  // update 
});

const onCompositionStart = (e) => {
  e.target.composing = true; // 标记合成事件
}

const onCompositionEnd = (e) => {
  const target = e.target;
  if (target.composing) { // 合成事件
    target.composing = false;
    trigger(target, 'input'); // 模拟触发input事件
  }
}

const trigger = (el, type) => {
  const e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
```

# v-bind