# 前言
前面花了五篇文章讲解petite-vue的指令和基础，我们得到一个可以跑得起来的轮子，今天想跳过这些语法与实现细节，从宏观的角度去窥探一下petite-vue的设计思路与流程控制的问题，5kb的一个库能涵盖vue的大部分特性，确实有些令人惊喜，下面就一层层剥开云雾吧。

# 模块组成
和vue类似，petite-vue也可以从三个方面来划分出基础模块；
## 1.响应式
依赖@vue/reactivity模块实现数据自动追踪，当数据发生变化时，与数据关联的副作用函数会被重新触发；
## 2.编译
petite-vue的编译相比vue来讲轻太多了，vue3自己实现了一套AST的解析与编译，而petite-vue则利用现有页面的DOM结构，petite-vue的编译主要集中在对DOM节点的遍历处理，初始化指令与上下文；
## 3.渲染
petite-vue中是没有专门的renderer的，定位不同，因此不需要那么复杂，这里指的渲染基本都是在effect中操作DOM完成的；

# 运行流程
<img src="./assets/6-1.png">
* 遍历DOM
以从根节点为起点，深度优先遍历所有节点，petite-vue通过walk和walkChildren完成这一阶段的工作，在遍历过程中，如果遇到对DOM结构有破坏性的指令(v-if/v-for)，则会先删除关联节点，然后通过副作用重构DOM结构；
* 指令初始化
当前遍历的节点如果有指令，则解析指令参数，然后交给对应的指令函数，例如v-if指令，就是交给if函数了，其中重要的一步就是将当前指令逻辑包裹在一个effect中，添加到调度器中的任务队列中等待执行，然后放入context.effects中，这样就建立了响应式基础；
* 调度
所有的effects的执行时机是由调度器(scheduler)控制的，在上一步中生成的effect都将放入scheduler中的队列中等待执行，执行完队列中的所有任务，清空队列，再追加任务执行；
* 副作用执行
副作用的执行由@vue/reactivity模块控制，当@vue/reactivity追踪的状态改变时，就会触发该状态对应的所有副作用函数执行，从而保证ui的更新，前面也说到副作用负责渲染工作，当然petite-vue里面没有专门的renderer，直接操作DOM，因此比较简单；

# context
context是一个比较重要的概念，是DOM与响应式之间的桥梁，
